-- Название: TurtleUiLib_SectionBased (Модифицированная версия)
-- Описание: UI-библиотека для создания ОДНОГО окна с разделами.

local library = {}

-- Сервисы и переменные
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui") -- Используем CoreGui для большей устойчивости

local LocalPlayer = Players.LocalPlayer
local mouse = LocalPlayer:GetMouse() -- Понадобится для слайдера, если он будет добавлен позже

local screenGui = nil -- Главный ScreenGui
local mainPanel = nil -- Основная панель (Frame)
local sectionContainer = nil -- ScrollingFrame для секций
local sectionListLayout = nil -- UIListLayout для секций
local currentSectionContentFrame = nil -- Frame текущей активной секции
local sectionVerticalOffsets = {} -- Хранит текущий Y-отступ для каждой секции {sectionContentFrame = offset}
local sectionHeights = {} -- Хранит текущую высоту контента каждой секции {sectionContentFrame = height}

local isPanelVisible = true -- Для сворачивания всей панели
local PADDING = 5 -- Отступы

-- Состояние перетаскивания
local dragging = false
local dragInput = nil
local dragStart = nil
local startPos = nil

-- Защита GUI (из оригинальной библиотеки)
local destroyed = false
if CoreGui:FindFirstChild('TurtleUiLib_SectionBased') then
    CoreGui:FindFirstChild('TurtleUiLib_SectionBased'):Destroy()
    destroyed = true
end

local function protect_gui(obj)
	if destroyed then
		obj.Parent = CoreGui
		return
	end
	if syn and syn.protect_gui then
		syn.protect_gui(obj)
		obj.Parent = CoreGui
	elseif PROTOSMASHER_LOADED then
		obj.Parent = get_hidden_gui()
	else
		obj.Parent = CoreGui
	end
end

-- Функция Lerp (из оригинальной библиотеки, может пригодиться для слайдеров)
function Lerp(a, b, c)
	return a + ((b - a) * c)
end

-- Функция Перетаскивания (применим к заголовку)
local dragConnection = nil
local function enableDrag(frame, handle)
	handle = handle or frame
	-- Отключаем старое соединение, если оно есть
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end

	local handleInputBeganConn, handleInputChangedConn, userInputEndedConn

	handleInputBeganConn = handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
			local changedConn, endedConn
			changedConn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					if changedConn then changedConn:Disconnect() end
					if endedConn then endedConn:Disconnect() end
				end
			end)
			endedConn = UserInputService.InputEnded:Connect(function(endInput)
				if endInput == input then
					dragging = false
					if changedConn then changedConn:Disconnect() end
					if endedConn then endedConn:Disconnect() end
				end
			end)
		end
	end)

	handleInputChangedConn = handle.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	-- Используем RenderStepped для обновления позиции во время перетаскивания
	dragConnection = RunService.RenderStepped:Connect(function()
		if dragging and dragInput then
			local currentPos = dragInput.Position
			local delta = currentPos - dragStart
			frame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end
	end)
end

-- Обновление CanvasSize контейнера секций
local function updateSectionContainerCanvasSize()
	if not sectionContainer or not sectionListLayout then return end

	local totalHeight = PADDING -- Начинаем с верхнего отступа
	for _, sectionFrame in ipairs(sectionContainer:GetChildren()) do
		if sectionFrame:IsA("Frame") and sectionFrame.Name == "SectionFrame" then
			totalHeight = totalHeight + sectionFrame.AbsoluteSize.Y + sectionListLayout.Padding.Offset
		end
	end
	sectionContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight)
end

-- === Публичные Функции Библиотеки ===

function library:Initialize(title, width)
	if screenGui then
		warn("Библиотека уже инициализирована.")
		return library -- Возвращаем себя для цепочки вызовов
	end

	title = title or "UI Library"
	width = width or 250
	local titleBarHeight = 30

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TurtleUiLib_SectionBased"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.DisplayOrder = 1000 -- Высокий порядок отображения

	mainPanel = Instance.new("Frame")
	mainPanel.Name = "MainPanel"
	mainPanel.Size = UDim2.new(0, width, 0, titleBarHeight) -- Начальная высота = только заголовок
	mainPanel.Position = UDim2.new(0, 20, 0, 20) -- Начальная позиция
	mainPanel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	mainPanel.BorderColor3 = Color3.fromRGB(80, 80, 80)
	mainPanel.BorderSizePixel = 1
	mainPanel.Active = true
	mainPanel.ClipsDescendants = true
	mainPanel.Parent = screenGui

	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, titleBarHeight)
	titleBar.BackgroundColor3 = Color3.fromRGB(0, 168, 255) -- Цвет из оригинала
	titleBar.BorderSizePixel = 0
	titleBar.Parent = mainPanel

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, -(titleBarHeight * 2) - (PADDING * 2), 1, 0) -- Место для кнопок
	titleLabel.Position = UDim2.new(0, PADDING, 0, 0)
	titleLabel.BackgroundTransparency = 1.000
	titleLabel.Font = Enum.Font.SourceSans -- Шрифт из оригинала
	titleLabel.Text = title
	titleLabel.TextColor3 = Color3.fromRGB(47, 54, 64) -- Цвет из оригинала
	titleLabel.TextSize = 17.000
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar

	-- Кнопка Закрытия (X)
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, titleBarHeight - PADDING * 2, 0, titleBarHeight - PADDING * 2)
	closeButton.Position = UDim2.new(1, -titleBarHeight + PADDING, 0, PADDING)
	closeButton.AnchorPoint = Vector2.new(1, 0)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Красный цвет
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Font = Enum.Font.SourceSansBold
	closeButton.Text = "X"
	closeButton.TextSize = 14
	closeButton.ZIndex = titleBar.ZIndex + 1
	closeButton.Parent = titleBar
	closeButton.MouseButton1Click:Connect(function()
		library:Destroy() -- Вызываем функцию уничтожения
	end)

	-- Кнопка Свернуть/Развернуть (_)
	local minimizeButton = Instance.new("TextButton")
	minimizeButton.Name = "MinimizeButton"
	minimizeButton.Size = UDim2.new(0, titleBarHeight - PADDING * 2, 0, titleBarHeight - PADDING * 2)
	minimizeButton.Position = UDim2.new(1, -(titleBarHeight * 2) + PADDING, 0, PADDING) -- Левее кнопки X
	minimizeButton.AnchorPoint = Vector2.new(1, 0)
	minimizeButton.BackgroundColor3 = Color3.fromRGB(0, 168, 255) -- Цвет из оригинала
	minimizeButton.BorderColor3 = Color3.fromRGB(0, 168, 255) -- Цвет из оригинала
	minimizeButton.TextColor3 = Color3.fromRGB(0, 0, 0) -- Цвет из оригинала
	minimizeButton.Font = Enum.Font.SourceSansLight -- Шрифт из оригинала
	minimizeButton.Text = "_"
	minimizeButton.TextSize = 20.000
	minimizeButton.ZIndex = titleBar.ZIndex + 1
	minimizeButton.Parent = titleBar

	-- Контейнер для секций
	sectionContainer = Instance.new("ScrollingFrame")
	sectionContainer.Name = "SectionContainer"
	sectionContainer.Size = UDim2.new(1, 0, 1, -titleBarHeight) -- Занимает все место под заголовком
	sectionContainer.Position = UDim2.new(0, 0, 0, titleBarHeight)
	sectionContainer.BackgroundColor3 = Color3.fromRGB(47, 54, 64) -- Цвет фона из оригинала
	sectionContainer.BorderColor3 = Color3.fromRGB(47, 54, 64) -- Цвет фона из оригинала
	sectionContainer.BorderSizePixel = 0
	sectionContainer.ScrollBarThickness = 4
	sectionContainer.CanvasSize = UDim2.new(0, 0, 0, 0) -- Начнем с нуля
	sectionContainer.Visible = isPanelVisible
	sectionContainer.Parent = mainPanel

	sectionListLayout = Instance.new("UIListLayout")
	sectionListLayout.Padding = UDim.new(0, PADDING)
	sectionListLayout.FillDirection = Enum.FillDirection.Vertical
	sectionListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	sectionListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sectionListLayout.Parent = sectionContainer

	-- Логика сворачивания/разворачивания всей панели
	minimizeButton.MouseButton1Click:Connect(function()
		isPanelVisible = not isPanelVisible
		sectionContainer.Visible = isPanelVisible
		if isPanelVisible then
			minimizeButton.Text = "_"
			-- Восстанавливаем размер панели (анимация опциональна)
			mainPanel.Size = UDim2.new(mainPanel.Size.X.Scale, mainPanel.Size.X.Offset, 0, titleBarHeight + sectionContainer.AbsoluteSize.Y) -- Приблизительно
			updateSectionContainerCanvasSize() -- Обновляем размер для скролла
		else
			minimizeButton.Text = "+"
			-- Сворачиваем панель до заголовка
			mainPanel.Size = UDim2.new(mainPanel.Size.X.Scale, mainPanel.Size.X.Offset, 0, titleBarHeight)
		end
	end)

	-- Активируем перетаскивание
	enableDrag(mainPanel, titleBar)

	-- Защищаем и добавляем в CoreGui
	protect_gui(screenGui)

	-- Обновляем размер после первой отрисовки
	RunService.Heartbeat:Wait()
	updateSectionContainerCanvasSize()

	print("TurtleUiLib_SectionBased Initialized.")
	return library -- Возвращаем библиотеку для цепочки вызовов
end

function library:AddSection(name)
	if not screenGui or not sectionContainer then
		warn("Библиотека не инициализирована. Вызовите library:Initialize() сначала.")
		return
	end

	name = name or "Section"
	local sectionHeaderHeight = 25

	-- Основной Frame для секции (Header + Content)
	local sectionFrame = Instance.new("Frame")
    sectionFrame.Name = "SectionFrame"
    sectionFrame.BackgroundTransparency = 1
    sectionFrame.Size = UDim2.new(1, -PADDING*2, 0, sectionHeaderHeight) -- Начнем с высоты заголовка
    sectionFrame.AutomaticSize = Enum.AutomaticSize.Y -- Автоматически изменяет высоту Y
    sectionFrame.LayoutOrder = #sectionContainer:GetChildren() + 1 -- Порядок добавления
    sectionFrame.Parent = sectionContainer

	-- Заголовок Секции
	local sectionHeader = Instance.new("Frame")
	sectionHeader.Name = "SectionHeader"
	sectionHeader.Size = UDim2.new(1, 0, 0, sectionHeaderHeight)
	sectionHeader.BackgroundColor3 = Color3.fromRGB(53, 59, 72) -- Темнее фона окна
	sectionHeader.BorderColor3 = Color3.fromRGB(113, 128, 147) -- Рамка из оригинала
	sectionHeader.BorderSizePixel = 1
	sectionHeader.Parent = sectionFrame

	local sectionTitle = Instance.new("TextLabel")
	sectionTitle.Name = "SectionTitle"
	sectionTitle.Size = UDim2.new(1, -sectionHeaderHeight - PADDING, 1, 0)
	sectionTitle.Position = UDim2.new(0, PADDING, 0, 0)
	sectionTitle.BackgroundTransparency = 1.0
	sectionTitle.Font = Enum.Font.SourceSansSemibold
	sectionTitle.Text = name
	sectionTitle.TextColor3 = Color3.fromRGB(245, 246, 250) -- Белый текст
	sectionTitle.TextSize = 16.000
	sectionTitle.TextXAlignment = Enum.TextXAlignment.Left
	sectionTitle.Parent = sectionHeader

	-- Кнопка сворачивания секции
	local sectionToggle = Instance.new("TextButton")
	sectionToggle.Name = "SectionToggle"
	sectionToggle.Size = UDim2.new(0, sectionHeaderHeight - PADDING, 0, sectionHeaderHeight - PADDING)
	sectionToggle.Position = UDim2.new(1, -sectionHeaderHeight, 0, PADDING/2)
	sectionToggle.AnchorPoint = Vector2.new(1, 0)
	sectionToggle.BackgroundColor3 = sectionHeader.BackgroundColor3
	sectionToggle.BorderSizePixel = 0
	sectionToggle.Font = Enum.Font.SourceSansLight
	sectionToggle.Text = "-" -- Начнем с развернутого состояния
	sectionToggle.TextColor3 = sectionTitle.TextColor3
	sectionToggle.TextSize = 20.000
	sectionToggle.Parent = sectionHeader

	-- Контейнер для содержимого секции
	local sectionContent = Instance.new("Frame")
	sectionContent.Name = "SectionContent"
	sectionContent.Size = UDim2.new(1, 0, 0, PADDING) -- Начнем с минимальной высоты (только отступ)
    sectionContent.AutomaticSize = Enum.AutomaticSize.Y -- Ключевой момент: авторазмер по Y
	sectionContent.Position = UDim2.new(0, 0, 0, sectionHeaderHeight)
	sectionContent.BackgroundTransparency = 1.0 -- Прозрачный фон
    sectionContent.ClipsDescendants = true -- Обрезать содержимое, если нужно
	sectionContent.Visible = true -- По умолчанию развернута
	sectionContent.Parent = sectionFrame

    local contentListLayout = Instance.new("UIListLayout")
    contentListLayout.Padding = UDim.new(0, PADDING)
    contentListLayout.FillDirection = Enum.FillDirection.Vertical
    contentListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    contentListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    contentListLayout.Parent = sectionContent

	-- Инициализация состояния для этой секции
    sectionVerticalOffsets[sectionContent] = PADDING -- Начинаем с отступа
    sectionHeights[sectionContent] = PADDING

	-- Логика сворачивания/разворачивания секции
	sectionToggle.MouseButton1Click:Connect(function()
		sectionContent.Visible = not sectionContent.Visible
		if sectionContent.Visible then
			sectionToggle.Text = "-"
		else
			sectionToggle.Text = "+"
		end
        -- Обновляем CanvasSize после изменения видимости (может потребоваться wait)
        RunService.Heartbeat:Wait()
		updateSectionContainerCanvasSize()
	end)


	-- Функции для добавления элементов в ЭТУ секцию
	local sectionFunctions = {}
	currentSectionContentFrame = sectionContent -- Устанавливаем текущую секцию

    -- Функция-хелпер для добавления элемента и обновления размера
    local function addElement(elementHeight)
        --[[ Старая логика расчета сдвигов (уже не нужна из-за UIListLayout и AutomaticSize)
        local currentOffset = sectionVerticalOffsets[sectionContent] or PADDING
        sectionVerticalOffsets[sectionContent] = currentOffset + elementHeight + PADDING

        local currentHeight = sectionHeights[sectionContent] or PADDING
        sectionHeights[sectionContent] = currentHeight + elementHeight + PADDING
        sectionContent.Size = UDim2.new(1, 0, 0, sectionHeights[sectionContent]) -- Обновляем размер контент-фрейма
        ]]

        -- Обновляем CanvasSize контейнера секций (после того как элемент добавлен и AutomaticSize сработал)
        RunService.Heartbeat:Wait() -- Даем время AutomaticSize обновить размер
        updateSectionContainerCanvasSize()
    end


	function sectionFunctions:Button(name, callback)
		local name = name or "Button"
		local callback = callback or function() end
		local elementHeight = 26 -- Высота кнопки

		local Button = Instance.new("TextButton")
		Button.Name = "Button_" .. name:gsub("%s+", "_") -- Уникальное имя
		Button.Parent = sectionContent -- Добавляем в контент секции
		Button.BackgroundColor3 = Color3.fromRGB(53, 59, 72) -- Цвет из оригинала
		Button.BorderColor3 = Color3.fromRGB(113, 128, 147) -- Цвет из оригинала
		Button.Size = UDim2.new(1, -PADDING*2, 0, elementHeight) -- Ширина с отступами
		Button.Font = Enum.Font.SourceSans
		Button.TextColor3 = Color3.fromRGB(245, 246, 250) -- Цвет из оригинала
		Button.TextSize = 16.000
		Button.TextWrapped = true
		Button.Text = name
		Button.MouseButton1Down:Connect(callback) -- Используем MouseButton1Down как в оригинале

        addElement(elementHeight) -- Обновляем размеры
		return Button -- Возвращаем кнопку, если нужно
	end

	function sectionFunctions:Label(text, color)
        local text = text or "Label"
		local color = color or Color3.fromRGB(220, 221, 225) -- Цвет из оригинала
        local elementHeight = 29 -- Высота лейбла

		local Label = Instance.new("TextLabel")
		Label.Name = "Label_" .. text:gsub("%s+", "_")
		Label.Parent = sectionContent
		Label.BackgroundTransparency = 1.000
        Label.Size = UDim2.new(1, -PADDING*2, 0, elementHeight) -- Ширина с отступами
        Label.Font = Enum.Font.SourceSans
		Label.Text = text
		Label.TextSize = 16.000
        Label.TextXAlignment = Enum.TextXAlignment.Left -- Выравнивание по левому краю
        Label.TextWrapped = true -- На случай длинного текста

		if type(color) == "boolean" and color then -- Радужный текст
			task.spawn(function()
                while Label and Label.Parent do -- Проверяем существование лейбла
					local hue = tick() % 5 / 5
					Label.TextColor3 = Color3.fromHSV(hue, 1, 1)
					RunService.Heartbeat:Wait()
				end
			end)
		else
			Label.TextColor3 = color
		end

        addElement(elementHeight)
		return Label
	end

    function sectionFunctions:Toggle(text, defaultState, callback)
        local text = text or "Toggle"
		local callback = callback or function() end
        local currentState = defaultState or false
        local elementHeight = 26

        local ToggleFrame = Instance.new("Frame")
        ToggleFrame.Name = "ToggleFrame_" .. text:gsub("%s+", "_")
        ToggleFrame.Size = UDim2.new(1, -PADDING*2, 0, elementHeight)
        ToggleFrame.BackgroundTransparency = 1.0
        ToggleFrame.Parent = sectionContent

        local ToggleDescription = Instance.new("TextLabel")
        ToggleDescription.Name = "ToggleDescription"
        ToggleDescription.Parent = ToggleFrame
        ToggleDescription.Size = UDim2.new(1, -elementHeight - PADDING, 1, 0) -- Место для кнопки
        ToggleDescription.BackgroundTransparency = 1.000
        ToggleDescription.Font = Enum.Font.SourceSans
        ToggleDescription.Text = text
        ToggleDescription.TextColor3 = Color3.fromRGB(245, 246, 250)
        ToggleDescription.TextSize = 16.000
        ToggleDescription.TextWrapped = true
        ToggleDescription.TextXAlignment = Enum.TextXAlignment.Left

        local ToggleButton = Instance.new("TextButton")
        ToggleButton.Name = "ToggleButton"
        ToggleButton.Parent = ToggleFrame
        ToggleButton.Size = UDim2.new(0, elementHeight, 0, elementHeight)
        ToggleButton.Position = UDim2.new(1, -elementHeight, 0, 0)
        ToggleButton.AnchorPoint = Vector2.new(1, 0)
        ToggleButton.BackgroundColor3 = Color3.fromRGB(47, 54, 64)
        ToggleButton.BorderColor3 = Color3.fromRGB(113, 128, 147)
        ToggleButton.Text = ""

        local ToggleFiller = Instance.new("Frame")
        ToggleFiller.Name = "ToggleFiller"
        ToggleFiller.Parent = ToggleButton
        ToggleFiller.BackgroundColor3 = Color3.fromRGB(68, 189, 50) -- Зеленый
        ToggleFiller.BorderColor3 = Color3.fromRGB(47, 54, 64)
        ToggleFiller.Position = UDim2.new(0, PADDING, 0, PADDING)
        ToggleFiller.Size = UDim2.new(1, -PADDING*2, 1, -PADDING*2) -- Занимает почти всю кнопку с отступами
        ToggleFiller.Visible = currentState

        ToggleButton.MouseButton1Click:Connect(function()
            currentState = not currentState
            ToggleFiller.Visible = currentState
            pcall(callback, currentState) -- Безопасный вызов callback
        end)

        addElement(elementHeight)
        return ToggleFrame -- Возвращаем фрейм для возможного управления
    end

    --[[ TODO: Добавить другие элементы управления (Box, Slider, Dropdown, ColorPicker),
             адаптировав их для работы с контентом секции и новой системой размеров.
             Это потребует значительной переработки их логики позиционирования и изменения размера.
             Пока оставим только Button, Label, Toggle для демонстрации.
    ]]

	-- Возвращаем таблицу с функциями для этой секции
	return sectionFunctions
end

function library:Destroy()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		mainPanel = nil
		sectionContainer = nil
        sectionListLayout = nil
		currentSectionContentFrame = nil
		sectionVerticalOffsets = {}
        sectionHeights = {}
		if dragConnection then dragConnection:Disconnect(); dragConnection = nil end
        print("TurtleUiLib_SectionBased Destroyed.")
	end
    -- Отключаем Keybind, если он был
    if keybindConnection then keybindConnection:Disconnect(); keybindConnection = nil end
end

-- Скрытие/Показ всей панели
local keybindConnection = nil
function library:Hide()
	if screenGui then
		screenGui.Enabled = not screenGui.Enabled
	end
end

-- Установка Keybind для Скрытия/Показа
function library:Keybind(key)
	if not UserInputService then return end -- На случай, если сервис не найден
	if keybindConnection then keybindConnection:Disconnect() end -- Отключаем старый

	local keyCodeEnum = Enum.KeyCode[key]
	if not keyCodeEnum then
		warn("Invalid keybind key:", key)
		return
	end

	keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
		if not gameProcessedEvent and input.KeyCode == keyCodeEnum then
			library:Hide()
		end
	end)
    print("Keybind set to:", key)
end

-- Возвращаем таблицу библиотеки
return library
